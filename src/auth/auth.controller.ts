import { Body, Controller, Get, Headers, HttpCode, HttpStatus, Post } from '@nestjs/common';
import { AuthService } from './auth.service';
import AuthSignInReqDto from './dto/req/auth-sign-in-req.dto';
import AuthSignUpReqDto from './dto/req/auth-sign-up-req.dto';
import { IsPublic } from './decorator';
import { AppException, ERROR_CODE } from '../exceptions';
import AuthCasSignInReqDto from './dto/req/auth-cas-sign-in-req.dto';
import AuthCasSignUpReqDto from './dto/req/auth-cas-sign-up-req.dto';
import UsersService from '../users/users.service';
import { ApiCreatedResponse, ApiHeader, ApiOkResponse, ApiOperation, ApiTags } from '@nestjs/swagger';
import AccessTokenResponse from './dto/res/auth-access-token-res.dto';
import TokenValidityResDto from './dto/res/token-validity-res.dto';
import CasLoginResDto from './dto/res/cas-login-res.dto';
import { ApiAppErrorResponse } from '../app.dto';

@Controller('auth')
@ApiTags('Authentication')
export class AuthController {
  constructor(private authService: AuthService, private usersService: UsersService) {}

  @IsPublic()
  @Post('signup')
  @ApiOperation({
    description: 'Signs up the user, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiCreatedResponse({
    description: 'The account was created successfully, the user is now authenticated and the token is returned.',
    type: AccessTokenResponse,
  })
  @ApiAppErrorResponse(
    ERROR_CODE.CREDENTIALS_ALREADY_TAKEN,
    'Login, email address or any field that should be unique is already taken',
  )
  async signup(@Body() dto: AuthSignUpReqDto): Promise<AccessTokenResponse> {
    const token = await this.authService.signup(dto);
    return { access_token: token };
  }

  @HttpCode(HttpStatus.OK)
  @IsPublic()
  @Post('signin')
  @ApiOperation({
    description: 'Signs in the user, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiOkResponse({
    description: 'The user was successfully authenticated, the token is returned.',
    type: AccessTokenResponse,
  })
  @ApiAppErrorResponse(ERROR_CODE.INVALID_CREDENTIALS, 'Either the login or the password is incorrect')
  async signin(@Body() dto: AuthSignInReqDto) {
    const token = await this.authService.signin(dto);
    if (!token) throw new AppException(ERROR_CODE.INVALID_CREDENTIALS);
    return { access_token: token };
  }

  @HttpCode(HttpStatus.OK)
  @IsPublic()
  @Get('signin')
  @ApiOperation({
    description: 'Checks if the user is signed in. It returns a boolean indicating if the user is signed in.',
  })
  @ApiHeader({
    name: 'Authorization',
    description: 'The token should be passed as a Bearer token, as if the user was signed in.',
    required: true,
  })
  @ApiCreatedResponse({
    description: 'The user is signed in.',
    type: TokenValidityResDto,
  })
  @ApiAppErrorResponse(ERROR_CODE.NO_TOKEN, 'The token was not passed in the `Authorization` header')
  @ApiAppErrorResponse(
    ERROR_CODE.INVALID_TOKEN_FORMAT,
    'The token is not in the right format. This may happen if you did not use the syntax `Bearer {token there}`, or the token was not generated by the API',
  )
  isSignedIn(@Headers() headers: Record<string, string>): TokenValidityResDto {
    const authorizationHeader = headers['authorization'];
    if (!authorizationHeader) {
      throw new AppException(ERROR_CODE.NO_TOKEN);
    }
    const match = new RegExp(/^Bearer\s+(.*)$/).exec(authorizationHeader);
    if (!match) {
      throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    }
    return { valid: this.authService.isTokenValid(match[1]) };
  }

  @IsPublic()
  @Post('signin/cas')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    description:
      'Signs in the user using CAS, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiCreatedResponse({
    description:
      'The CAS ticket was successfully validated. If signedIn is true, the user is authenticated and can use the access_token to authenticate his requests. If signedIn is false, the user should use the access_token to sign up with "POST /auth/signup/cas".',
    type: AccessTokenResponse,
  })
  async casSignIn(@Body() dto: AuthCasSignInReqDto): Promise<CasLoginResDto> {
    const res = await this.authService.casSignIn(dto.service, dto.ticket);
    if (res.status === 'invalid') {
      throw new AppException(ERROR_CODE.INVALID_CAS_TICKET);
    }
    return { signedIn: res.status === 'ok', access_token: res.token };
  }

  @IsPublic()
  @Post('signup/cas')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({
    description:
      'Signs up the user using CAS, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiCreatedResponse({
    description:
      'The account was successfully created. The token to authenticate the following requests is passed in the body',
  })
  @ApiAppErrorResponse(
    ERROR_CODE.INVALID_TOKEN_FORMAT,
    'The format of the token is invalid. This may happen if the token used is not one provided by the API',
  )
  @ApiAppErrorResponse(
    ERROR_CODE.CREDENTIALS_ALREADY_TAKEN,
    'Login, email, or any other field that should be unique about a user is already bound to another user',
  )
  async casSignUp(@Body() dto: AuthCasSignUpReqDto) {
    const data = this.authService.decodeRegisterToken(dto.registerToken);
    if (!data) throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    if (await this.usersService.doesUserExist({ login: data.login }))
      throw new AppException(ERROR_CODE.CREDENTIALS_ALREADY_TAKEN);
    const token = await this.authService.signup(data, true);
    return { access_token: token };
  }
}
