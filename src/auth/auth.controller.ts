import { Body, Controller, Get, Headers, HttpCode, HttpStatus, Post } from '@nestjs/common';
import { AuthService } from './auth.service';
import AuthSignInReqDto from './dto/req/auth-sign-in-req.dto';
import AuthSignUpReqDto from './dto/req/auth-sign-up-req.dto';
import { IsPublic } from './decorator';
import { AppException, ERROR_CODE } from '../exceptions';
import AuthCasSignInReqDto from './dto/req/auth-cas-sign-in-req.dto';
import AuthCasSignUpReqDto from './dto/req/auth-cas-sign-up-req.dto';
import UsersService from '../users/users.service';
import { ApiCreatedResponse, ApiHeader, ApiOkResponse, ApiOperation, ApiTags } from '@nestjs/swagger';
import AuthSigninResDto from './dto/res/auth-signin-res.dto';
import TokenValidityResDto from './dto/res/token-validity-res.dto';
import CasLoginResDto from './dto/res/cas-login-res.dto';
import { ApiAppErrorResponse } from '../app.dto';
import { GetApplication } from './decorator/get-application.decorator';
import CreateApiKeyReqDto from './dto/req/create-api-key-req.dto';
import ApplicationService from './application/application.service';
import { Application } from './application/interfaces/application.interface';
import AuthValidateReqDto from './dto/req/auth-validate-req.dto';
import { ConfigModule } from '../config/config.module';
import AuthTokenResDto from './dto/res/auth-token-res.dto';
import AuthRedirectionResDto from './dto/res/auth-redirection-res.dto';

@Controller('auth')
@ApiTags('Authentication')
export class AuthController {
  constructor(
    private authService: AuthService,
    private usersService: UsersService,
    private applicationService: ApplicationService,
    private config: ConfigModule,
  ) {}

  @IsPublic()
  @Post('signup')
  @ApiOperation({
    description: 'Signs up the user, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiCreatedResponse({
    description: 'The account was created successfully, the user is now authenticated and the token is returned.',
    type: AuthSigninResDto,
  })
  @ApiAppErrorResponse(
    ERROR_CODE.CREDENTIALS_ALREADY_TAKEN,
    'Login, email address or any field that should be unique is already taken',
  )
  async signup(@Body() dto: AuthSignUpReqDto, @GetApplication() application: Application): Promise<AuthSigninResDto> {
    const token = await this.authService.signup(dto, application.id, false, dto.tokenExpiresIn);
    const redirectUrl = `${application.redirectUrl}/${token}`;
    return { signedIn: true, token, redirectUrl };
  }

  @HttpCode(HttpStatus.OK)
  @IsPublic()
  @Post('signin')
  @ApiOperation({
    description: 'Signs in the user, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiOkResponse({
    description: 'The user was successfully authenticated, the token is returned.',
    type: AuthSigninResDto,
  })
  @ApiAppErrorResponse(ERROR_CODE.INVALID_CREDENTIALS, 'Either the login or the password is incorrect')
  async signin(@Body() dto: AuthSignInReqDto, @GetApplication() application: Application): Promise<AuthSigninResDto> {
    const res = await this.authService.signin(dto.login, dto.password, application.id);
    if (!res) throw new AppException(ERROR_CODE.INVALID_CREDENTIALS);
    if (!res.apiKey)
      return {
        signedIn: false,
        token: await this.authService.signRegisterApiKeyToken(res.userId, application.id, dto.tokenExpiresIn),
        redirectUrl: null,
      };
    if (application.id === this.config.ETUUTT_WEBSITE_APPLICATION_ID)
      return {
        signedIn: true,
        token: await this.authService.signApiKey(res.apiKey.id, dto.tokenExpiresIn),
        redirectUrl: null,
      };
    const token = await this.authService.signValidationToken(
      res.apiKey.id,
      application.id,
      dto.tokenExpiresIn,
    );
    return {
      signedIn: true,
      token: null,
      redirectUrl: this.formatRedirectUrl(application.redirectUrl, token),
    };
  }

  @HttpCode(HttpStatus.OK)
  @IsPublic()
  @Get('signin')
  @ApiOperation({
    description: 'Checks if the user is signed in. It returns a boolean indicating if the user is signed in.',
  })
  @ApiHeader({
    name: 'Authorization',
    description: 'The token should be passed as a Bearer token, as if the user was signed in.',
    required: true,
  })
  @ApiCreatedResponse({
    description: 'The user is signed in.',
    type: TokenValidityResDto,
  })
  @ApiAppErrorResponse(ERROR_CODE.NO_TOKEN, 'The token was not passed in the `Authorization` header')
  @ApiAppErrorResponse(
    ERROR_CODE.INVALID_TOKEN_FORMAT,
    'The token is not in the right format. This may happen if you did not use the syntax `Bearer {token there}`, or the token was not generated by the API',
  )
  isSignedIn(@Headers() headers: Record<string, string>): TokenValidityResDto {
    const authorizationHeader = headers['authorization'];
    if (!authorizationHeader) {
      throw new AppException(ERROR_CODE.NO_TOKEN);
    }
    const match = new RegExp(/^Bearer\s+(.*)$/).exec(authorizationHeader);
    if (!match) {
      throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    }
    return { valid: this.authService.isTokenValid(match[1]) };
  }

  @IsPublic()
  @Post('signin/cas')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    description:
      'Signs in the user using CAS, and returns an token. This token should be used as a Bearer token (if application is the EtuUTT website) or should be passed to `POST /auth/validate`.',
  })
  @ApiCreatedResponse({
    description:
      'The CAS ticket was successfully validated.\n' +
      "If status is 'ok', the user is authenticated. Either use the token to authenticate his requests (if application is the EtuUTT website) or pass it to `POST /auth/validate` (if application is not the EtuUTT website).\n" +
      "If the status is 'no_api_key', the user should use the token to register an api key for the application. See `POST /auth/api-key\n" +
      "If status is 'no_account', the user should use the token to sign up with `POST /auth/signup/cas`.",
    type: AuthSigninResDto,
  })
  async casSignIn(
    @Body() dto: AuthCasSignInReqDto,
    @GetApplication() application: Application,
  ): Promise<CasLoginResDto> {
    const res = await this.authService.casSignIn(dto.service, dto.ticket, application.id);
    if (!res) throw new AppException(ERROR_CODE.INVALID_CAS_TICKET);
    if (!res.userId)
      return {
        status: 'no_account',
        token: await this.authService.signRegisterUserToken(
          res.basicUserData.login,
          res.basicUserData.mail,
          res.basicUserData.firstName,
          res.basicUserData.lastName,
          dto.tokenExpiresIn,
        ),
        redirectUrl: null,
      };
    if (!res.apiKeyId)
      return {
        status: 'no_api_key',
        token: await this.authService.signRegisterApiKeyToken(res.userId, application.id, dto.tokenExpiresIn),
        redirectUrl: null,
      };
    if (application.id === this.config.ETUUTT_WEBSITE_APPLICATION_ID)
      return {
        status: 'ok',
        token: await this.authService.signApiKey(res.apiKeyId, dto.tokenExpiresIn),
        redirectUrl: null,
      };
    const token = await this.authService.signValidationToken(
      res.apiKeyId,
      application.id,
      dto.tokenExpiresIn,
    );
    return {
      status: 'ok',
      token: null,
      redirectUrl: this.formatRedirectUrl(application.redirectUrl, token),
    };
  }

  @IsPublic()
  @Post('signup/cas')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({
    description:
      'Signs up the user using CAS, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiCreatedResponse({
    description:
      'The account was successfully created. The token to authenticate the following requests is passed in the body',
  })
  @ApiAppErrorResponse(
    ERROR_CODE.INVALID_TOKEN_FORMAT,
    'The format of the token is invalid. This may happen if the token used is not one provided by the API',
  )
  @ApiAppErrorResponse(
    ERROR_CODE.CREDENTIALS_ALREADY_TAKEN,
    'Login, email, or any other field that should be unique about a user is already bound to another user',
  )
  async casSignUp(
    @Body() dto: AuthCasSignUpReqDto,
    @GetApplication('id') application: string,
  ): Promise<AuthTokenResDto> {
    const data = this.authService.decodeRegisterUserToken(dto.registerToken);
    if (!data) throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    if (await this.usersService.doesUserExist({ login: data.login }))
      throw new AppException(ERROR_CODE.CREDENTIALS_ALREADY_TAKEN);
    const token = await this.authService.signup(data, application, true, data.tokenExpiresIn);
    return { token };
  }

  @IsPublic()
  @Post('/api-key')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({
    description:
      'Creates an API Key to allow user to connect to an application through EtuUTT. Returns a token that can be used to authenticate requests',
  })
  @ApiCreatedResponse({
    description:
      'Create an API access for user to the application that made the request. Returns an authentication token. A route to sign-in should be called before, to get the required token in body.',
  })
  async createApiKey(@Body() dto: CreateApiKeyReqDto): Promise<AuthRedirectionResDto> {
    const data = this.authService.decodeRegisterApiKeyToken(dto.token);
    if (!data) throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    if (!(await this.usersService.doesUserExist({ id: data.userId })))
      throw new AppException(ERROR_CODE.NO_SUCH_USER, data.userId); // Can only happen if user has deleted his account
    const application = await this.applicationService.get(data.applicationId);
    if (!application) throw new AppException(ERROR_CODE.NO_SUCH_APPLICATION, data.applicationId); // Can only happen if application has been deleted
    const apiKey = await this.authService.createApiKey(data.userId, data.applicationId);
    const token = await this.authService.signValidationToken(
      apiKey.id,
      application.id,
      data.tokenExpiresIn,
    );
    const redirectUrl = this.formatRedirectUrl(application.redirectUrl, token);
    return { redirectUrl };
  }

  @IsPublic()
  @Post('/login/validate')
  @ApiOperation({
    description:
      'Returns a bearer token from a validation token. Validation token is what is returned after the signing in. Most probably, you will get this token when user is redirected to your website after you asked them to sign in',
  })
  @HttpCode(HttpStatus.OK)
  async validate(
    @Body() dto: AuthValidateReqDto,
    @GetApplication() application: Application,
  ): Promise<AuthTokenResDto> {
    const data = this.authService.decodeValidationToken(dto.token);
    if (!data) throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    if (data.applicationId !== application.id) throw new AppException(ERROR_CODE.INCONSISTENT_APPLICATION);
    if (dto.clientSecret !== application.clientSecret) throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT); // Should we return a specific error for this ? That would also give some info about what the problem is to a malicious person.
    const token = await this.authService.signApiKey(data.apiKeyId, data.tokenExpiresIn);
    if (!token) throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    return { token };
  }

  private formatRedirectUrl(redirectUrl: string, validationToken: string): string {
    return `${redirectUrl}?${new URLSearchParams({ token: validationToken }).toString()}`;
  }
}
