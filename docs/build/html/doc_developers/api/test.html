<!DOCTYPE html>
<html class="writer-html5" lang="fr" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Test &mdash; Documentation EtuUTT </title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=d1a510d7"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/translations.js?v=d99ca74e"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Recherche" href="../../search.html" />
    <link rel="next" title="Entry" href="timetables.html" />
    <link rel="prev" title="Conventions" href="conventions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            EtuUTT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Rechercher docs" aria-label="Rechercher docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Sommaire</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Documentation développeurs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Documentation développeurs - API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="setup.html">Setup de l’API EtuUTT</a></li>
<li class="toctree-l3"><a class="reference internal" href="technologies.html">Technologies</a></li>
<li class="toctree-l3"><a class="reference internal" href="conventions.html">Conventions</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Test</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#suite">Suite</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-fakedb">Module fakedb</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="timetables.html">Entry</a></li>
<li class="toctree-l3"><a class="reference internal" href="timetables.html#occurrence">Occurrence</a></li>
<li class="toctree-l3"><a class="reference internal" href="timetables.html#override">Override</a></li>
<li class="toctree-l3"><a class="reference internal" href="timetables.html#groupe-devenements">Groupe d’événements</a></li>
<li class="toctree-l3"><a class="reference internal" href="timetables.html#priorite">Priorité</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../front/index.html">Documentation développeurs - Site web</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile_app/index.html">Documentation EtuUTT - Application mobile</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">EtuUTT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Documentation développeurs</a></li>
          <li class="breadcrumb-item"><a href="index.html">Documentation développeurs - API</a></li>
      <li class="breadcrumb-item active">Test</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/doc_developers/api/test.md.txt" rel="nofollow"> Afficher la source de la page</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="test">
<h1>Test<a class="headerlink" href="#test" title="Link to this heading"></a></h1>
<p>Pour les tests, nous utilisons Jest.</p>
<p>Dans la CLI, quand on exécute les tests, il faut absolument passer le paramètre <code class="docutils literal notranslate"><span class="pre">--runInBand</span></code>, pour éviter que les tests
ne s’exécutent en parallèle. Le paramètre est passé par défaut dans les commandes <code class="docutils literal notranslate"><span class="pre">package.json</span></code></p>
<p>Les tests sont divisés en 2 parties :</p>
<ul class="simple">
<li><p>E2E (End-to-End) : tous les tests testant des routes, en simulant une requête d’un client.</p></li>
<li><p>Unit (Unitaires) : les tests unitaires permettent de tester une partie de l’API. Il n’y en a pas pour toutes les
parties de l’API, uniquement les plus complexes, là où c’est jugé nécessaire.</p></li>
</ul>
<section id="suite">
<h2>Suite<a class="headerlink" href="#suite" title="Link to this heading"></a></h2>
<p>Une suite est un ensemble de test permettant de tester une fonctionnalité : route, service, … Une suite représente en
réalité une simple fonction qui, une fois exécutée, crée un <code class="docutils literal notranslate"><span class="pre">describe()</span></code> avec un <code class="docutils literal notranslate"><span class="pre">beforeAll()</span></code> pré-généré.
Ce <code class="docutils literal notranslate"><span class="pre">beforeAll</span></code> permet notamment de vider complètement la base de données. La fonction permettant de créer une suite
prend 2 paramètres, les mêmes qu’un <code class="docutils literal notranslate"><span class="pre">describe</span></code> : le nom de la suite et le callback. Le callback prend un argument :
l’<code class="docutils literal notranslate"><span class="pre">AppProvider</span></code>. L’<code class="docutils literal notranslate"><span class="pre">AppProvider</span></code> est utilisé pour toutes les interactions avec l’API : requêtes, Prisma, …</p>
<p>De la même manière qu’il y a 2 types de tests, il y a 2 types de suites et d’<code class="docutils literal notranslate"><span class="pre">AppProvider</span></code> : les suites
E2E / <code class="docutils literal notranslate"><span class="pre">E2EAppProvider</span></code>, et les suites unitaires / <code class="docutils literal notranslate"><span class="pre">UnitAppProvider</span></code>. Voici donc comment vous pouvez créer une suite pour
tester la route <code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/users/:id</span></code> :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">e2eSuite</span><span class="p">,</span><span class="w"> </span><span class="nx">E2EAppProvider</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../../utils/test_utils&#39;</span><span class="p">;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">GetUserFromIdE2ESpec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">e2eSuite</span><span class="p">(</span><span class="s1">&#39;GET /users/:userId&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">app</span><span class="o">:</span><span class="w"> </span><span class="kt">E2EAppProvider</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Insérez les tests ici : initialisation, it(), ...</span>
<span class="p">});</span>

<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">INestApplication</span><span class="p">,</span><span class="w"> </span><span class="nx">VersioningType</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>

<span class="c1">// Fonction dans le fichier e2e/app.e2e-spec.ts, exécutant tous les tests E2E</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;E2E Spec&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">app</span><span class="o">:</span><span class="w"> </span><span class="kt">INestApplication</span><span class="p">;</span>
<span class="w">  </span><span class="nx">beforeAll</span><span class="p">(</span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Création de l&#39;app</span>
<span class="w">    </span><span class="nx">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">await</span><span class="w"> </span><span class="nx">Test</span><span class="p">.</span><span class="nx">createTestingModule</span><span class="p">({</span><span class="w"> </span><span class="nx">imports</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">AppModule</span><span class="p">]</span><span class="w"> </span><span class="p">}).</span><span class="nx">compile</span><span class="p">()).</span><span class="nx">createNestApplication</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// ... Reste de l&#39;initialisation de l&#39;app.</span>
<span class="w">  </span><span class="p">});</span>
<span class="w">  </span><span class="nx">GetUserFromIdE2ESpec</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">app</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</section>
<section id="module-fakedb">
<h2>Module fakedb<a class="headerlink" href="#module-fakedb" title="Link to this heading"></a></h2>
<p>Le module <code class="docutils literal notranslate"><span class="pre">fakedb</span></code> est un module simplifiant grandement l’écriture de tests, permettant notamment de générer plus
facilement des données de test. Le module abstrait beaucoup de fonctions que vous utilisez habituellement, assurez-vous
donc de bien lire et comprendre cette partie de la documentation.</p>
<section id="plugin-faker">
<h3>Plugin faker<a class="headerlink" href="#plugin-faker" title="Link to this heading"></a></h3>
<p>Nous utilisons un plugin faker personnalisé, nous permettant de simplifier la création de code de semestres, d’UEs, etc.
Ce plugin permet aussi d’éviter, pour les champs uniques, de générer plusieurs fois les mêmes valeurs. Toutes les
additions de ce plugin sont dans l’objet <code class="docutils literal notranslate"><span class="pre">faker.db</span></code>. Cet objet a pour clés le nom de tables (plus précisément, les clés
de <code class="docutils literal notranslate"><span class="pre">FakeEntityMap</span></code>, voir plus bas). Les valeurs de cet objet sont des noms de colonnes de cette table. Par exemple, si
je veux générer le nom d’un semestre, je peux faire :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nx">faker</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;@/faker-js/faker&#39;</span><span class="p">;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">semestre</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">faker</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">semester</span><span class="p">.</span><span class="nx">code</span><span class="p">();</span>
</pre></div>
</div>
<p>Si une valeur unique est hardcodée (par exemple, un numéro de semestre qui ne serait pas généré aléatoirement) dans un
test, la fonction <code class="docutils literal notranslate"><span class="pre">registerUniqueValue</span></code> du module. Dans le cas où je veux par exemple créer un semestre A24 dans un
test :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">registerUniqueValue</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;&lt;path_to_root_directory&gt;/prisma/seed/utils&#39;</span><span class="p">;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">semestre</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeSemester</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createSemester</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="kt">registerUniqueValue</span><span class="p">(</span><span class="s1">&#39;semester&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;code&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;A24&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<p>Pour le moment, ne vous préoccupez pas de <code class="docutils literal notranslate"><span class="pre">createSemester</span></code> et <code class="docutils literal notranslate"><span class="pre">FakeSemester</span></code>, leur nom sont suffisamment explicites pour
le moment.</p>
<p>Tous les champs uniques ne sont pas représentés. C’est le cas notamment des UUIDs, qui sont bien trop nombreux pour
qu’il y ait un intérêt à les représenter.</p>
<p>Si un champ est complexe à générer aléatoirement, on peut très bien l’ajouter dans le plugin, mais évidemment sans
appeler la fonction <code class="docutils literal notranslate"><span class="pre">registerUniqueValue</span></code> dessus.</p>
</section>
<section id="creation-dentites">
<h3>Création d’entités<a class="headerlink" href="#creation-dentites" title="Link to this heading"></a></h3>
<p>Dans cette section, ce que l’on nomme une “entité” est une entrée d’une certaine table dans la base de données. Par
exemple, l’utilisateur qui me représente est une entrée, le semestre A24 est une entrée, etc.</p>
<p>À toute entité que l’on pourrait vouloir générer de façon aléatoire, on définit un type qui représente une version
“fake” de cette entité (<em>fake entity</em>). Ces versions fake sont <code class="docutils literal notranslate"><span class="pre">Partial</span></code>, ce qui signifie qu’aucun de leur champ n’est
obligatoire : on peut toutes leur assigner la valeur <code class="docutils literal notranslate"><span class="pre">{}</span></code>. La plupart du temps, ces versions fake sont exactement les
versions raw (celles qui sont directement données par prisma, telles qu’elles sont définies dans la base de données,
sans relations), passées dans le type <code class="docutils literal notranslate"><span class="pre">Partial</span></code> évidemment. Cependant, certaines entités générées aléatoirement peuvent
être plus complexes, par exemple un utilisateur : il aura ses données par défaut (<code class="docutils literal notranslate"><span class="pre">RawUser</span></code>), quelques informations
supplémentaires (<code class="docutils literal notranslate"><span class="pre">RawUserInfos</span></code>), ainsi qu’un token (pour authentifier ses requêtes) et un tableau de ses permissions :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">FakeSemester</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Partial</span><span class="o">&lt;</span><span class="nx">RawSemester</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Exemple d&#39;un type fake simple.</span>
<span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">FakeUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Partial</span><span class="o">&lt;</span><span class="nx">RawUser</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">RawUserInfos</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">permissions</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">[];</span><span class="w"> </span><span class="nx">token</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">}</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Exemple d&#39;un type fake plus complexe.</span>
</pre></div>
</div>
<p><strong>Création de fake entities</strong></p>
<p>Ensuite, pour générer une fake entity, vous pouvez appeler la fonction
correspondante : <code class="docutils literal notranslate"><span class="pre">createUser</span></code>, <code class="docutils literal notranslate"><span class="pre">createSemester</span></code>, … (<em>fake functions</em>)</p>
<p>Les fake functions sont toutes définies de la même façon :</p>
<ul>
<li><p>Le premier argument est l’<code class="docutils literal notranslate"><span class="pre">AppSupplier</span></code>.</p></li>
<li><p>Le deuxième argument (<code class="docutils literal notranslate"><span class="pre">dependencies</span></code>) est un objet de paramètres obligatoires (<strong>dépendances</strong>) : ils peuvent par
exemple représenter d’autres fake entities. Pour créer une filière par exemple, on doit avoir une branche créée
préalablement, et créer la filière pour cette branche. On passera donc le paramètre <code class="docutils literal notranslate"><span class="pre">branch</span></code> dans cet objet.</p>
<p>Ce deuxième argument n’est pas toujours existant, si l’entité ne contient pas de dépendances. Les arguments suivants
seront donc <em>techniquement</em> mal numérotés dans la documentation, mais pour un souci de clarté, nous allons quand
même appeler l’argument suivant le “troisième”, même si pour certaines fonctions, ça sera le deuxième.</p>
</li>
<li><p>Le troisième argument (<code class="docutils literal notranslate"><span class="pre">rawParams</span></code>) est un objet permettant de passer les autres paramètres, tous optionnels. Cela
signifie que vous pouvez passer <code class="docutils literal notranslate"><span class="pre">{}</span></code>. Si besoin, des valeurs par défaut seront utilisées (nous allons voir comment ces
valeurs sont définies plus tard). Ce paramètre est optionnel, si vous n’avez pas besoin de passer d’argument,
omettez-le.</p></li>
<li><p>Le quatrième argument (<code class="docutils literal notranslate"><span class="pre">onTheFly</span></code>) permet de définir le comportement de la fonction :</p>
<ul class="simple">
<li><p>S’il vaut <code class="docutils literal notranslate"><span class="pre">true</span></code>, on crée l’entité directement.</p></li>
<li><p>S’il vaut <code class="docutils literal notranslate"><span class="pre">false</span></code>, l’entité sera créée dans un bloc <code class="docutils literal notranslate"><span class="pre">beforeAll</span></code>.</p></li>
</ul>
<p>L’argument est optionnel, et vaut par défaut <code class="docutils literal notranslate"><span class="pre">false</span></code>. Donc :</p>
<ul class="simple">
<li><p>Si vous appelez la fonction dans un <code class="docutils literal notranslate"><span class="pre">describe</span></code> (ou équivalent), ne passez pas cet argument.</p></li>
<li><p>Si vous appelez la fonction dans un <code class="docutils literal notranslate"><span class="pre">it</span></code>, donnez la valeur <code class="docutils literal notranslate"><span class="pre">true</span></code> au paramètre.</p></li>
</ul>
</li>
</ul>
<p>Voici plusieurs exemples d’utilisation de ces fonctions :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">fakedb</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../../utils/fakedb&#39;</span><span class="p">;</span>

<span class="nx">e2eSuite</span><span class="p">(</span><span class="s2">&quot;Foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">app</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Vous pouvez aussi utiliser unitSuite, ou n&#39;importe quoi d&#39;autre, tant que c&#39;est équivalent à un describe() et que vous pouvez avoir l&#39;app.</span>
<span class="w">  </span><span class="nx">beforeAll</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">fonctionTest</span><span class="p">());</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">branche</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeBranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fakedb</span><span class="p">.</span><span class="nx">createBranch</span><span class="p">(</span><span class="nx">app</span><span class="p">);</span><span class="w"> </span><span class="c1">// Branch n&#39;a pas de dépendance</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">semestre</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeSemester</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fakedb</span><span class="p">.</span><span class="nx">createSemester</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="kt">registerUniqueValue</span><span class="p">(</span><span class="s1">&#39;semester&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;code&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;A24&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// Semester n&#39;a pas de dépendance</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">filiere</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeBranchOption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createBranchOption</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">branch</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// BranchOption a 1 dépendance: Branch</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">ue</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createUE</span><span class="p">(</span>
<span class="w">      </span><span class="nx">app</span><span class="p">,</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">semesters</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">semestre</span><span class="p">],</span><span class="w"> </span><span class="nx">branchOption</span><span class="o">:</span><span class="w"> </span><span class="kt">filiere</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="c1">// UE a 2 dépendances : une liste de Semester, et une BranchOption</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="kt">registerUniqueValue</span><span class="p">(</span><span class="s1">&#39;XX03&#39;</span><span class="p">),</span>
<span class="w">        </span><span class="nx">credits</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">          </span><span class="p">{</span>
<span class="w">            </span><span class="nx">category</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CS&#39;</span><span class="p">,</span>
<span class="w">              </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CS&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="nx">credits</span><span class="o">:</span><span class="w"> </span><span class="kt">6</span><span class="p">,</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">        </span><span class="p">],</span>
<span class="w">      </span><span class="p">},</span><span class="w"> </span><span class="c1">// We passed quite a lot of parameters there, they are all optional, we can remove any one of them.</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">;</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">fonctionTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Les objets que nous avons créés sont toujours vides</span>
<span class="w">    </span><span class="c1">// (le beforeAll qui appelle cette fonction a été défini au tout début, il sera donc appelé avant tous les autres beforeAll.</span>
<span class="w">    </span><span class="c1">// Les objets ont quand même été créés, ils n&#39;ont juste pas été remplis)</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">semestre</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeUndefined</span><span class="p">();</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">semestre</span><span class="p">.</span><span class="nx">code</span><span class="p">).</span><span class="nx">toBeUndefined</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fakedb</span><span class="p">.</span><span class="nx">createUser</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// User n&#39;a pas de dépendance. On le crée à la volée :</span>
<span class="w">                                                             </span><span class="c1">// à la fin de l&#39;appel à la fonction, user sera rempli et aura été sauvegardé dans la base de données</span>
<span class="w">    </span><span class="c1">// Ici, la base de donnée a été seed, les objets ne sont plus vides.</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">semestre</span><span class="p">.</span><span class="nx">code</span><span class="p">).</span><span class="nx">toBeEqual</span><span class="p">(</span><span class="s1">&#39;A24&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">id</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeUndefined</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Les types des paramètres des différentes fonctions se trouvent dans l’interface <code class="docutils literal notranslate"><span class="pre">FakeEntityMap</span></code>. Sa structure est la
suivante :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span><span class="w"> </span><span class="nx">FakeEntityMap</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[</span><span class="nx">nom_de_table</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">entity</span><span class="o">:</span><span class="w"> </span><span class="kt">TypeEntityFake</span><span class="p">;</span>
<span class="w">    </span><span class="nx">params</span><span class="o">:</span><span class="w"> </span><span class="kt">TypeParametresOptionnels</span><span class="p">;</span>
<span class="w">    </span><span class="nx">deps?</span><span class="o">:</span><span class="w"> </span><span class="kt">TypeDependances</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// 2 exemples :</span>
<span class="w">  </span><span class="nx">branch</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">entity</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeBranch</span><span class="p">;</span>
<span class="w">    </span><span class="nx">params</span><span class="o">:</span><span class="w"> </span><span class="kt">CreateBranchParameters</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="nx">branchOption</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">entity</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeBranchOption</span><span class="p">;</span>
<span class="w">    </span><span class="nx">params</span><span class="o">:</span><span class="w"> </span><span class="kt">CreateBranchOptionParameters</span><span class="p">;</span>
<span class="w">    </span><span class="nx">deps</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">branch</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeBranch</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On peut accéder aux types directement, ou plus facilement en utilisant les 3 types suivants :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">Entity</span><span class="o">&lt;</span><span class="nx">T</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="nx">FakeEntityMap</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">FakeEntityMap</span><span class="p">[</span><span class="nx">T</span><span class="p">][</span><span class="s1">&#39;entity&#39;</span><span class="p">];</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Params</span><span class="o">&lt;</span><span class="nx">T</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="nx">FakeEntityMap</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">FakeEntityMap</span><span class="p">[</span><span class="nx">T</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">];</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Deps</span><span class="o">&lt;</span><span class="nx">T</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="nx">FakeEntityMap</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">FakeEntityMap</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">deps</span><span class="o">:</span><span class="w"> </span><span class="kt">infer</span><span class="w"> </span><span class="nx">R</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">R</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Record</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">never</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Ces 3 types prennent en paramètre le nom de la table (<code class="docutils literal notranslate"><span class="pre">branch</span></code>, <code class="docutils literal notranslate"><span class="pre">user</span></code>, <code class="docutils literal notranslate"><span class="pre">semester</span></code>, <code class="docutils literal notranslate"><span class="pre">branchOption</span></code>, …).</p>
<p>Tous les outils développés et documentés dans la suite de cette partie ont permis d’obtenir ce résultat : leur code est
difficile à lire à cause de sa complexité, mais nous pensons qu’ils permettent de grandement simplifier la lisibilité,
l’écriture, la redondance du code ensuite. Il n’y a que quelques centaines de lignes tout au plus de code fortement
typé (et assez abstrait), normalement, vous serez capable de comprendre le fonctionnement global de ces lignes à la fin
de la partie suivante.</p>
<p><strong>Création de fake functions</strong></p>
<p>Une fonction pour générer une entité fake ressemble à ça :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">createBranchOption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">OnTheFly</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="nx">app</span><span class="o">:</span><span class="w"> </span><span class="kt">AppProvider</span><span class="p">,</span>
<span class="w">    </span><span class="nx">dependencies</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeEntityMap.branchOption.deps</span><span class="p">,</span>
<span class="w">    </span><span class="nx">rawParams</span><span class="o">:</span><span class="w"> </span><span class="kt">FakeEntityMap.branchOption.params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{},</span>
<span class="w">    </span><span class="nx">onTheFly</span><span class="o">:</span><span class="w"> </span><span class="kt">OnTheFly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">OnTheFly</span><span class="p">,</span>
<span class="w">  </span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">OnTheFly</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Entity</span><span class="o">&lt;</span><span class="s1">&#39;branchOption&#39;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">Entity</span><span class="o">&lt;</span><span class="s1">&#39;branchOption&#39;</span><span class="o">&gt;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// L&#39;entité qui sera retournée, pleine ou vide en fonction de la variable de onTheFly</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">lazyEntity</span><span class="o">:</span><span class="w"> </span><span class="kt">Entity</span><span class="o">&lt;</span><span class="s1">&#39;branchOption&#39;</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="c1">// La fonction qui sera appelée pour créer la fake entity</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Paramètres par défaut</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="kt">faker.db.branch.code</span><span class="p">(),</span>
<span class="w">        </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">faker.name.jobTitle</span><span class="p">(),</span>
<span class="w">        </span><span class="p">...</span><span class="nx">rawParams</span><span class="p">,</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">Params</span><span class="o">&lt;</span><span class="s1">&#39;branchOption&#39;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">      </span><span class="c1">// Création de l&#39;entité</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">entity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">app</span><span class="p">().</span><span class="nx">get</span><span class="p">(</span><span class="nx">PrismaService</span><span class="p">).</span><span class="nx">uTTBranchOption</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span><span class="w"> </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Paramètres de création */</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">});</span>
<span class="w">      </span><span class="c1">// On injecte la valeur en entity dans lazyEntity, de manière à modifier la valeur de la référence</span>
<span class="w">      </span><span class="c1">// Si on avait directement fait lazyEntity = entity, on aurait modifié la valeur pointée par la variable</span>
<span class="w">      </span><span class="c1">// et donc la variable détenant la valeur retournée par createBranchOption resterait inchangée</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">lazyEntity</span><span class="p">,</span><span class="w"> </span><span class="nx">entity</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">onTheFly</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// On retourne directement le retour de la factory.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nx">factory</span><span class="p">()</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">OnTheFly</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Entity</span><span class="o">&lt;</span><span class="s1">&#39;branchOption&#39;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">never</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// On ajoute un beforeAll, qui appelera la factory.</span>
<span class="w">    </span><span class="nx">beforeAll</span><span class="p">(</span><span class="nx">factory</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Et on retourne la référence du lazyEntity. Quand le beforeAll sera appelé, lazyEntity sera rempli</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">lazyEntity</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">OnTheFly</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">never</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Entity</span><span class="o">&lt;</span><span class="s1">&#39;branchOption&#39;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">;</span>
</pre></div>
</div>
<p>Ne cherchez pas ce code, il n’existe pas, ou du moins pas sous cette forme. On vous l’a mis là pour que vous puissiez
bien saisir la logique des fake functions. On remarque vite que la logique pour toutes les fake functions est exactement
la même, et que le code est donc très redondant. Voici donc à quoi ressemble la définition réelle
de <code class="docutils literal notranslate"><span class="pre">createBranchOption</span></code> :</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">createBranchOption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">entityFaker</span><span class="p">(</span>
<span class="w">  </span><span class="s1">&#39;branchOption&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nx">code</span><span class="o">:</span><span class="w"> </span><span class="kt">faker.db.branchOption.code</span><span class="p">,</span>
<span class="w">    </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">faker.name.jobTitle</span><span class="p">,</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">app</span><span class="p">,</span><span class="w"> </span><span class="nx">dependencies</span><span class="p">,</span><span class="w"> </span><span class="nx">params</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span>
<span class="w">    </span><span class="nx">app</span><span class="p">()</span>
<span class="w">      </span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">PrismaService</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="nx">uTTBranchOption</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
<span class="w">      </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Paramètres de création */</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}),</span>
<span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">entityFaker</span></code> est une fonction permettant de créer des fake functions. La fake function générée par entity faker a
exactement le même comportement que celle que nous avons détaillée au-dessus. Détaillons chacun de ses paramètres :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_kind</span></code> : le type de la fake function à créer. C’est le nom d’une table (plus précisément d’une clé
de <code class="docutils literal notranslate"><span class="pre">FakeEntityMap</span></code>). Il permet de déduire le type des paramètres, des dépendances, et de la fake entity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultParams</span></code> : les paramètres par défaut de la fake function. Ce doit être un subset du type des <code class="docutils literal notranslate"><span class="pre">params</span></code> de la
fake entity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">entityFactory</span></code> : une fonction retournant une <code class="docutils literal notranslate"><span class="pre">Promise</span></code> de la fake entity. Elle prend en paramètre l’<code class="docutils literal notranslate"><span class="pre">AppProvider</span></code>,
les dépendances et les paramètres de la fake entity que nous voulons créer. Si la fake entity n’a pas de dépendance,
la fonction ne prend que 2 paramètres, le paramètre n’est pas passé.</p></li>
</ul>
<p>La fonction retourne alors une fonction prenant 3 ou 4 paramètres (en fonction de l’existence ou non de dépendances dans
la <code class="docutils literal notranslate"><span class="pre">FakeEntityMap</span></code>). La fake function est ainsi utilisable comme nous l’avons vu jusqu’alors.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Pied de page">
        <a href="conventions.html" class="btn btn-neutral float-left" title="Conventions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Précédent</a>
        <a href="timetables.html" class="btn btn-neutral float-right" title="Entry" accesskey="n" rel="next">Suivant <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Droits d'auteur 2024, UTT Net Group.</p>
  </div>

  Compilé avec <a href="https://www.sphinx-doc.org/">Sphinx</a> en utilisant un
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">thème</a>
    fourni par <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>